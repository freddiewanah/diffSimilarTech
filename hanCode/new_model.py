
from bert_serving.client import BertClient

import os
import pickle
from nltk.parse import CoreNLPParser
from nltk import pos_tag
from gensim.similarities import WmdSimilarity
import gensim
import datetime
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from sklearn.cluster import AgglomerativeClustering
import scipy.cluster.hierarchy as sch
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN, OPTICS
from sklearn.neighbors import NearestNeighbors
import tensorflow as tf
import tensorflow_hub as hub
import numpy as np
import datetime

# Prepare stop words set
stop_words = pickle.load(open(os.path.join(os.pardir, "data", "stop_words.pkl"), 'rb'))

pair = ["interpreted-language", "compiled-language"]

sentences = ["a compiled-language will generally run faster than an interpreted-language so i think ruby and php start behind the eight ball but it really comes down to how you use the language and how you structure the code", "an interpreted-language will typically run one to two orders of magnitude slower than a compiled-language", "and perl like any interpreted-language is much slower than a compiled-language", "are compiled-language better than interpreted-language or vice-versa", "fact is that interpreted-language like php are always slower than a compiled-language", "from what i know a compiled-language such as c++ is much faster than an interpreted-language such as javascript", "in my general programming experience compiled c c++ programs generally run faster than most other compiled-language like java or even compiled python and almost always run faster than interpreted-language like uncompiled python or javascript", "interpreted-language execution speed are slower than compiled-language true but once there is need for more speed you can call in compiled stuff through gems or micro services", "interpreted-language tend to be but not always are significantly slower than compiled-language", "it should be noted that interpreted-language are inherently many time slower than natively compiled-language", "mostly interpreted-language are a bit slower compared with compiled-language but i guess the difference is almost negligible in coffeescript javascript because of node.js", "naturally interpreted-language will run slower than compiled-language as compiled code can be ran blindly by the cpu where as compiled code needs to be checked ran line by line", "php is an interpreted-language so will run a little slower than a compiled-language", "python is an interpreted-language so by definition is slower than other compiled-language but the drawback in the execution speed is not even noticeable in most of applications", "that being said a compiled-language like c will almost always be faster than an interpreted-language like javascript", "this is a good question but should be formulated a little different in my opinion for example why are interpreted-language slower than compiled-language", "this makes interpreted-language generally slower than compiled-language due to the overhead of running the vm or interpreter", "while ruby and python are both interpreted-language and operation-for-operation slower than compiled-language the reality is in executing an application only a small portion of cpu time is spent in your code and the majority is spent into the built-in libraries you call into which are often native implementations and thus are as fast as compiled code", "performance of programs in compiled-language is significantly better than that of an interpreted-language", "writing in a compiled-language java or c++ in your examples would almost certainly give better performance than an interpreted-language like php", "while java could be described as a compiled and interpreted-language it s probably easier to think of java itself as a compiled-language and java bytecode as an interpreted-language", "an interpreted-language surely makes it easier but this is still entirely possible with compiled-language like c", "interpreted-language are inherently less performant than compiled-language - c will generally outperform python - some operations more than others", "then c which is one those languages closer to the processor level is very performant and generally speaking compiled-language because they turn your code into assembly language are more performant than interpreted-language", "my guess is that in interpreted-language the efficiency benefit in using switch statements is indeed smaller than in compiled-language", "this is usually seen in dynamic interpreted-language but is less common in compiled-language", "especially in an interpreted-language like php where classes add more overhead than a compiled-language"]

sentences3 = ["asymptotic analysis reveals order of growth of heapsort in the worst case is big-o n logn which is better than quicksort s big-o n 2 as a worst case", "average asymptotic order of quicksort is o nlogn and it s usually more efficient than heapsort due to smaller constants tighter loops", "because heapsort is actually slower than quicksort for each n", "but there are many citations of real world tests which show that heapsort is significantly slower than quicksort on average", "each iteration in quicksort is a lot simpler than heapsort", "for example quicksort average cost t n.log n and heapsort average cost t n.log n are both sorting algorithms with the same average cost - yet quicksort is typically much faster than heapsort", "for example quicksort is faster than heapsort in general although their time complexity are the same", "from what i heard quicksort should have better average case performance but from my tests it performs 4 times worse than heapsort for array of random integers", "heapsort has a better big-o than say quicksort yet quicksort performs much better in practice", "however heapsort is slower than quicksort in the average case in the sense that heapsort performs c n log n whereas quicksort has d n log n performance with d being significantly smaller than c the numbers c and d are constants", "however heapsort is somewhat slower in practice on most machines than a well-implemented quicksort", "if i do heapsort i can create the stack while i m sorting but would this be faster than a quicksort and then build the stack afterwords", "in fact the heapsort algorithm works this way first arrange a random order into heap order and then obtain a sorted order somewhat less efficient than quicksort on average", "in practice however quicksort is usually faster then heapsort", "in the event that the quicksort starts to degenerate it uses heapsort which is o n log n worst-case but slightly slower than quicksort on average to guarantee o n log n worst-case runtimes", "in their respective worst cases heapsort is faster than quicksort", "it is a variant of heapsort which is particularly suitable for the sorting of very large amounts of data if a relatively high cost per compare operation is needed and on average better than quicksort", "quicksort time complexity is typically o n log n but it s worst case is o n 2 which is avoided with the switch to heapsort since heapsort is always o n log n but slower than quicksort so it s only used to avoid o n 2", "so for even small inputs quicksort does less work than heapsort and is physically faster for every n", "so for instance heapsort is faster than quicksort in the worst case but slower in the average case", "the difference is large enough that the constant factor in front of the n log n term in quicksort is lower than the constant factor in front of the n log n term in heapsort which is one reason why quicksort is much faster than heapsort", "this is because quicksort is generally faster than heapsort unless the call depth becomes to deep", "what makes quicksort faster than heapsort in practice is its constant that was ignored by big o analysis", "when you say something like heapsort should be faster than quicksort what makes you say that", "why it is said quicksort has better constant factor than heapsort and therefore quicksort is better than heapsort in average", "worst case for quicksort is actually worse than heapsort and mergesort but quicksort is faster on average", "heapsort has higher overhead than quicksort but its worst case is o n log n vs", "in other words the per-comparison-overhead of heapsort is higher than the one of quicksort", "in short - if all we care about are comparisons heapsort is a better choice than quicksort", "can anyone explain why heapsort performs better and under what circumstances quichesort would be better than both quicksort and heapsort", "you can indeed show that on average quicksort will do more comparisons than heapsort roughly 1.44 n log 2 n for quicksort versus n log 2 n versus heapsort", "however quicksort s worst-case performance is significantly worse than heapsort s is", "in theory quicksort is worse than heapsort", "in theory insertion sort and quicksort are worse than heapsort", "for 5 000 000 ints still stored in memory quicksort becomes suddenly worse then heapsort and mergesort", "after several tests i found out that my heapsort is way quicker than quicksort i think it should be the other way around my selection sort is also faster than insertion sort", "i was just going to say radix sort however that could be a bit above what you were looking to implement introsort is generally the accepted sorting solution for data it s a variation of quicksort that switches to heapsort when it reaches smaller sets as it s faster on smaller sets than quicksort", "quicksort also has a better cache access behavior than heapsort", "the reason heapsort is slower in practice than quicksort is due to the better locality of reference in quicksort where data elements are within relatively close storage locations"]

sentences2 = ["sorteddictionary has faster insertion and removal operations for unsorted data o log n as opposed to o n for sortedlist", "note after doing some benchmarks i found that sorteddictionary is faster for removal but sortedlist is faster for adding and indexing by key", "â sortedlist uses less memory than sorteddictionary", "sortedlist tkey tvalue uses less memory than sorteddictionary tkey", "sortedlist is faster when you want to enumerate the elements and you can access the elements by index and sorteddictionary is faster if there are a lot of elements and you want to insert a new element in the middle of the collection", "sortedlist is faster than sorteddictionary", "if the list is populated all at once from sorted data sortedlist is faster than sorteddictionary", "sortedlist uses less memory than sorteddictionary", "ignoring the cost of providing sorted input the oh of sortedlist is smaller than the oh of sorteddictionary", "i had one further issue that related to the oncollectionchanged - the notifycollectionchangedeventargs required an index as opposed to the item of the sorteddictionary which is doesn t come out of the box it s easier with a sortedlist but anyhow", "you should also keep in mind that sortedlist performs worse than sorteddictionary during construction if the items are not inserted in already-sorted order although in this particular case it is highly likely that dates are inserted in chronological sorted order which would be perfect"]

sentences4 = ["a hood technique is to tag milestone releases of your projects giving then a version number and then manage dependencies with maven or a similar tool a bit more sophisticated than ant", "ant is older and while it is still used in a number of projects it is rapidly losing ground to maven", "ant is simpler and older and the default just called a java project maven is newer more powerful and flexible", "also maven projects come with a different directory structure and seems to be doing much more than what ant does in the spring source tutorial", "so i suggest you build a p2 repository can be done in ant but seems simpler in maven tycho and split the projects to several repositories", "while i personally think maven is a better tool than ant in the long run our experience will make maven3 a better tool than maven2", "while you can munge together a solution with ant maven is a better solution for managing dependencies than ant", "if you want to stick to lower level basic file operations ant is better bet than maven", "however some things ant handles better than maven and if there s not a maven plugin for it it may be difficult to handle in maven", "i also find ant with ivy to be better documented than maven although that s not too difficult", "maven definitely has better integration with flex than ant", "and it turns out maven really does a better job of managing dependencies for ant build.xml files than does ivy", "can maven examine and resolve internal dependencies of non-mavenized jar library defined earlier by ant", "maven is better for managing dependencies but ant is ok with them too if you use ant+ivy and build artefacts", "ant pre-dates more modern tools like maven and gradle that have this feature baked in", "maven is a better alternative as build system compared to ant", "the size of maven jar is bigger then ant jar i don t know why help me please", "i think updating dependencies with maven is pretty easier than dealing with ant but of course you could select the other way if you feel more conifrtable", "maven is definitely better than ant and well used for big projects", "you can take a look on gradle which for me could provide more freedom than maven but is easier to use than ant", "this question is similar in nature to whether ant is better than maven or c# better than java", "trust me i did this before for another job where the system architect decided that maven was better than ant and all of our projects must be converted from ant to maven", "does this make ant more complex than maven", "i know maven is more powerful than ant", "ant is much more powerful than maven in many respects but maven excels in dependency management and ease of deployment", "but as i checked-out some example apps from spring source repo and it seems that maven is more preferred and powerful than ant", "1 - why ant script generates more .class files than maven", "maven can t be compared with ant as in maven vs ant maven is more than a build script than ant is", "also note that while maven is no slower than ant for multi-module projects of this sort importing your maven project into an ide will generally result in far faster builds than maven can perform itself", "alternate build tools ant lots of configuration gradle conventions again less verbose than maven", "as you ve already said ant is more a replacement for gnu make while maven is primary a buildout dependency-management application", "but maven and ant are so different that there is no real point at comparing them and maven is still much more than ant + dependency management", "did maven has achieved more then ant or ant is still alive", "first maven is a much younger tool than ant or make so you have to expect that its going to take time to get to the maturity level of those applications", "first of all ant is older than maven and therefore does not include core support for dependency management", "i d definitely use ant or maven - my preference is ant because it s more flexible and i think it would suit your development style more than maven as well", "i find the ant one much clearer than the maven one", "i guess that the maven version contains much more than the ant version", "in jacoco 0.7.9 there are jacoco ant tasks and in 0.8.0 there will be jacoco command line interface - both provide more freedom than jacoco maven plugin in specification of what should be included into report in particular can be used for arbitrary third-party jar files", "maven is higher level than make makefile the classic c c++ build tool or ant build.xml", "maven is more like a replacement for ant", "maven is more of a meta-program that can use ant scripts and run your junit tests", "maven is more or less an update concept of ant", "maven usage is lower compared to ant but just how much lower is not really known", "since ant is more of a scripting tool and doesn t impose structure or lifecycle like maven and gradle you simply manually invoke ant when you want to use it", "the quotation you brought up just claim that maven does more than ant so that it s not fair to compare the two", "troubleshooting the build maven is less reliable than ant especially the non-core plugins"]

sentences5=["as gnibbler pointed out cpython is slower in the simple implementation but pypy is jit compiled for much faster code when you need it", "can someone please help to how use that script using the pypy as i heard it is much faster than cpython", "cpython is faster than pypy on the two tests slowspitfire and waf", "for python there is a pypy project which it includes jit making possible the code to run faster than in cpython in many cases", "however consider that pypy might do the linear search 100 times faster than cpython then a few times might be dozens", "i finally ran it through pypy and was delighted to discover that when the lists got really deep pypy was running significantly faster than cpython", "i haven t tried comparing the two but this pypy bug seems to suggest that multiprocessing in pypy is slower than in cpython", "i presume it s why is pypy faster than cpython some of the time", "i saw that pypy is generally faster than cpython", "i ve tried using pypy because i ve heard its faster than the cpython interpreter but still no good", "if that isn t sufficient a lot of standard python code can be run on the pypy implementation which generally faster than the cpython implementation", "in the competing programming a lot of problems are never meant to be solved with cpython but with pypy which has a faster integer-arithmetic and a git-compiler but otherwise a python interpreter just as cpython", "judging from the benchmarks posted on the pypy speed center it appears as if pypy is faster than cpython for all but two of the tests presented", "just keep in mind most of the time c is faster than python but then again most of the time pypy is faster than cpython", "jython is more unpredictableâ sometimes almost as fast as pypy sometimes much slower than cpython", "note that there are plenty of python implementations other than cpython out there - for loopy code pypy tends to be much faster than cpython", "part of the compiler toolchain includes an experimental jit generator now in its fifth incarnation and starting to work really well - the goal is for a jited pypy to run much faster than cpython", "pypy compiled with jit is almost always faster than cpython frequently by a large margin", "pypy is currently more than 5x faster than cpython on average", "pypy is faster than cpython s sum intrinsic because it can figure out that all the elements of the array are numeric and slice out a bunch of per-element overhead", "pypy is now faster than cpython in most cases", "pypy is supposedly faster than cpython while gevent is based on co-routines and greenlets which supposedly makes for a faster web server", "pypy s jit can make python code execute much faster than cpython", "pypy which in general is much faster than cpython is considerably slower for this use case", "so how is it possible for pypy to be faster than cpython also becomes fairly obvious", "some people may argue with me on this one but i find pypy to be faster than cpython", "that site does not claim pypy is 6.3 times faster than cpython", "the answer is simple here - pickle on pypy is slower because it s implemeneted in pure python as opposed to c in cpython", "the pypy jit for python is also much more complex than cpython but also typically much faster â increased complexity is a fairly typical cost for speed. the four levels of disassembly for julia code give you access to the representation of a julia method implementation for particular argument types at different stages of the transformation from source code to machine code", "this is why pypy may be slower than cpython sometimes it needs a warm-up phase in which it can actually optimize repeated operations", "under cpython tests run 4 times faster than under pypy", "unfortunately as martijn pieters noted there are no accepted solution for python 3.x and only one for python 2.x and according to the amount of memory spent for solving it numerix could have used psyco the library on which pypy is based much faster than cpython", "you could try running it in pypy - for some cases it can be significantly faster than cpython", "you might want to try running your trainer under pypy if you aren t already -- it s significantly faster than cpython for some workloads", "if the dominant memory usage is program data structures then i wouldn t be at all surprised to find pypy using significantly less memory than cpython whether or not the jit was enabled", "when people talk about pypy using less memory than cpython this is a major part of what they re talking about", "as mentioned by ifloop this would be running a cpython c extension module on pypy which often works not always but is slower than on cpython", "but for a really useful explanation you d have to tell us exactly which database and library you re using and which python versionâ cpython 3.3.2 s csv module seems to be a lot faster than cpython 2.7.5 s and pypy 2.1 2.7.2 seems to be faster than cpython 2.7.5 as well but then either one also might run your code faster tooâ and so on", "cpython runs on more architectures than pypy and has been successfully adapted to run in embedded architectures in ways that may be impractical for pypy", "edit again one completely different approach would be to use pypy s sandboxing mechanism which should be much more secure than cpython plus a sandboxing module", "further the relative speed of profiled code may well differ hugely between them - pypy code is low-level and so introducing profiling is likely to slow it down relatively speaking more than cpython", "i did a search on the web but i was unable to find any evidence that suggests that pypy s memory usage is much more than cpython", "i know many of pypy s data structures are actually smaller than cpython s but again that has nothing to do with the jit", "if pypy succeeds to be better than cpython in general which is questionable the main weakness affecting its wider adoption will be its compatibility with cpython", "long-term evidence is showing that pypy runs certain python codes slower than cpython and this drawback seems to be rooted very deeply in pypy", "now there are some implementations like pypy rpython which run a static-typing phase and should favor much better than cpython here", "profiling is known to slow pypy a lot more than cpython", "pypy has a higher recursion limit than cpython normally", "secondly the current version of pypy consumes much more memory than cpython in a rather large set of cases", "so at this point in time pypy is just over 9 times faster than cpython in this micro benchmark", "the waf benchmark has less of a pronounced difference in performance and i d guess that the answer would be more complicated some factors pypy does better some factors cpython does better and overall cpython comes out slightly ahead"]

sentences6 = ["my ipad 1 safari js benchmarked 38 times slower than google-chrome on my pc", "if i try to do a google search for website loading slower in google-chrome than in safari i get a lot of results about how safari is slower than google-chrome", "the one used by google-chrome and is slower than mobile safari s nitro javascript engine", "safari will display fonts without a specified size significantly smaller than in google-chrome", "safari 5.1.10 6534.59.10 middle handles a smaller viewport but in sort order with a smaller viewport computes new image sizes even smaller than google-chrome", "safari makes child block s height larger than google-chrome", "google-chrome also uses an earlier version of webkit than the current safari so pages should be checked in both browsers", "it also gets broken even more in ios google-chrome which is an older version of safari", "safari still uses the older version while google-chrome uses a more current one", "it s not even a webkit issue unless google-chrome s got a newer version than safari", "google-chrome also is susceptible to this same issue although it does a significantly better job than safari at getting the realtime api re-connected", "this seems to me like a bandwidth error or something like that originally i ve got the error when i played with the html 5 audio api and if i loaded the audio file 10-15 times sequentially then i ve got the error but now i ve discovered that i get the error without the audio api too just by reloading the site a lots of times also safari gives me the error much faster than google-chrome wtf", "safari comes in at just under 41ms performing better than google-chrome but still not great", "i think safari renders the moves better than google-chrome", "i guess firefox and safari handle huge numbers of elements better than google-chrome", "a lot of people use iphones ipads and safari is literally the only option even google-chrome is more like safari in disguise... so it s quite a portion of users who are suffering from this issue", "conclusion diff1 is faster in firefox opera and safari diff2 is faster in ie and google-chrome", "dus anyone knows if there is something wrong with my json or if google-chrome is harder to get than safari", "from testing this in google-chrome and safari it seems google-chrome is more forgiving in that it parses the style string and puts the right style in place for you but safari does not", "google-chrome has more of the market than safari not and invitation for flame wars just a personal opinion without any weight -", "google-chrome is worse than safari", "i also have .js files being redirected to javascript engines as well for main.js in google-chrome it tries main.v8.js in safari main.nitro.js in firefox main.gecko.js", "i read somewhere that safari has more stringent requirements on cross domain scripting - it and google-chrome share the same code base", "in any case vorbis clearly has the most coverage google-chrome has more of the market than safari now opera is about half of safari and obviously firefox is huge and it doesn t really have the strong opposition that theora has", "in safari the background of my menu navigation drop-down menu s is much wider than in google-chrome firefox", "ios google-chrome is more ios safari than google-chrome itself", "okay safari ios is more strict than google-chrome android when it comes to this all fine but it still needs to enable me to allow the connection through", "safari 5.1 still renders smoother than google-chrome but it is now clear that google has done much improvement", "safari is more funny than google-chrome i can easily make google-chrome cache my page but safari does not", "safari is more secure than ie or google-chrome", "safari renders open sans bolder than in google-chrome so you would need to apply a lighter font weight for safari open sans google web fonts rendering in google-chrome", "so if something works on safari it s more likely to work straightaway on google-chrome more than it is on firefox - but that s just a family resemblance at the end of the day you ll still have to test each as every webkit browser product and version still uses a different version of webkit", "the browser does not matter though safari gets way more consistently working results than google-chrome", "the safari controller bar is the quicktime bar which is smaller and dark so the movement is less noticeable than google-chrome which has a big blue progress bar", "total width of button in safari web inspector 6px larger than in google-chrome web inspector"]

sentences7 =["as many people have noted the average case performance for quicksort is faster than mergesort", "depending on where i look people say quicksort is faster than mergesort due to its locality of reference cache hits etc", "for the 10 tests on the same list the results should be quite the same at least all showing that quicksort is faster than mergesort or vice vesa", "from what i ve read i was expecting quicksort to be faster than mergesort but on my code it is not so i assume there must be a problem with my quicksort algorithm", "however on smaller int sizes quicksort gets slower and mergesort gets faster", "i have been testing the practicality of openmp gnu parallel sort algorithms in the c++ standard library and have found the parallel quicksort algorithm to be significantly slower than the mergesort algorithm", "i have read that quicksort is much faster than mergesort in practise and the reason for this is the hidden constant", "i ve looked at the question at why is quicksort better than mergesort", "i would say that the quicksort is simpler for parallelizing than the mergesort", "in most cases quicksort will run faster than mergesort even though the worst-case execution time is longer", "when comparing my quicksort implementation with std sort on my compiler and my implementation of mergesort i noticed an odd pattern on large data sets when operating on 64 bit integers quicksort is consistently faster than mergesort", "it might be helpful to see why quicksort is usually faster than mergesort since if you understand the reasons you can pretty quickly find some cases where mergesort is a clear winner", "it s because that quicksort is generally faster that people use it instead of mergesort", "mergesort - in general mergesort is consistently faster than quicksort however quicksort is done in place and doesn t require allocating memory unlike mergesort", "mergesort is slightly slower than quicksort but it does not have quicksort s susceptibility to pathological cases", "when comparison function is a callback function like in quicksort libc implementation quicksort is slower than mergesort by 15 on random input and 30 for already sorted array for 64 bit integers", "normally quicksort is faster than mergesort which is faster than heapsort", "parallelizing mergesort is simpler than quicksort in-place", "previously discussed on so why is quicksort better than mergesort", "purely in terms of the number of comparisons performed is mergesort always more efficient than quicksort", "quicksort consistently has less recursive calls than mergesort", "quicksort generally runs faster than mergesort but under some circumstances it can degrade to quadratic running time", "quicksort has better locality of reference than mergesort which means that the accesses performed in quicksort are usually faster than the corresponding accesses in mergesort", "quicksort is approximately 40 faster than mergesort on random data because of fewer data movements", "quicksort is implemented well it is typically 2-3 times faster than mergesort or", "quicksort is not better than mergesort", "quicksort is usually faster than mergesort just because it s easier to code a tight implementation and the operations it does can go faster", "quicksort usually is better than mergesort for two reasons", "scenarios when quicksort is worse than mergesort", "that way quicksort can reach recursive base case more quicker than mergesort", "the quicksort algorithm is faster than mergesort which is what sorted will get you when called on a sequence of objects via java.util.arrays.sort", "to be specific the quicksort runs faster than mergesort in the first test case and loses badly in the following 9 tests", "why is quicksort better than mergesort", "you can also see that for smaller collections quicksort is faster but then mergesort takes the lead but all of this is case specific so take your time to study all 4 algorithms", "an interesting answer about this can be found at why is quicksort better than mergesort", "for example locality of references has influence on cache hits or misses which is the reason why quicksort performs better than mergesort", "for instance quicksort can outperform mergesort although mergesort is provably better than quicksort in the worst case", "given that it is possible to vastly reduce the likelihood of the worst case of quicksort s time complexity via random selection of the pivot for example i think one could argue that mergesort is worse in all but the pathological case of quicksort", "i know mergesort is better since it is stable and doesn t have n 2 as worst case but i required to implement quicksort", "mergesort may use more space than quicksort i m not entirely sure and merge may be better for linkedlists", "quicksort is not better it is well suited for a different kind of application than mergesort", "quicksort is worse complexity than mergesort in the worst case.", "technically mergesort has a better time-behavior î nlogn worst and average cases than quicksort î n 2 worst case î nlogn average case", "mergesort uses about 30 less comparisons than quicksort", "interestingly quicksort performs more comparisons on average than mergesort - 1.44 n lg n expected for quicksort versus n lg n for mergesort", "also note that quicksort is generally more optimal than mergesort see this as well which explains why it s taken advantage of when sorting primitives", "i do know though that quicksort has more compares but less swaps than mergesort which i learned from another stackoverflow discussion quicksort vs merge sort", "i had been taught that quicksort is almost always quicker than mergesort and i understand that there is some debate on this topic but i at least expected it to be closer than this", "mergesort is more natural to implement for linked lists but you can do quicksort very nicely", "quicksort is also more complicated than mergesort especially if you want to write a really solid implementation and so if you re aiming for simplicity and maintainability merge sort becomes a promising alternative with very little performance loss", "quicksort is more sensitive to input sortedness in a positive way than mergesort", "that s hard to say.the worst of mergesort is n log2n -n+1 which is accurate if n equals 2 k i have already proved this .and for any n it s between n lg n - n + 1 and n lg n + n + o lg n .but for quicksort its best is nlog2n also n equals 2 k .if you divide mergesort by quicksort it equals one when n is infinite.so it s as if the worst case of mergesort is better than the best case of quicksort why do we use quicksort", "the biggest difference that can be produced between the two of them will always be to quicksort s detriment and it involves lists that are already largely sorted or contain a large number of ties when quicksort does better than mergesort the difference will not be nearly so great", "this means that while the two underlying sorts it uses mergesort and insertion sort are both worse than quicksort for many kinds of data timsort only uses them when it is advantageous to do so"]

sentences8= ["the reason for using lxml for such a task is that it cleans html files better than beautifulsoup do", "regarding beautifulsoup lxml is more efficient and in my experience can handle broken html better than beautifulsoup", "note that lxml is probably a better option than beautifulsoup for this kind of task nowadays for the reasons given by beautifulsoup s author", "beautifulsoup is more suitable for html parsing than lxml", "i would recommend lxml for html parsing it s simple and considerably faster than beautifulsoup can be as much as two orders of magnitude", "i found a solution to this problem using beautifulsoup at beautifulsoup-where-are-you-putting-my-html because i think it is easier than lxml", "lxml will let you use xpath here which i think will be less painful than beautifulsoup s interface", "lxml enables you to search for elements using xpath which i think is easier than using beautifulsoup s api", "according to some benchmark tests lxml is nearly 100 times faster than beautifulsoup", "according to the above posts and my own experience lxml is definitely faster than beautifulsoup", "alternatively you can use lxml module which is lot faster than beautifulsoup", "edit don t use this for html work use the lxml library it s python based and much faster than beautifulsoup", "how can i find all div and span tags with order preserved.with beautifulsoup it is very simple but i switched recently to lxml since it is much faster than beautifulsoup", "i prefer to use beautifulsoup better than lxml", "i prefere lxml it s a harder to understand but much faster than beautifulsoup", "i ve found that even if lxml is faster than beautifulsoup for documents that size it s usually best to try to reduce the size to a few kb via regex or direct stripping and load that into bs as you are doing now", "it s generally accepted that lxml is faster than beautifulsoup ref", "it uses lxml underneath and is much faster than beautifulsoup", "lxml is also much much faster than beautifulsoup", "lxml is faster than beautifulsoup i think and has much better functionality while remaining relatively easy to use", "lxml is much faster than beautifulsoup and probably the fastest parser available for python", "lxml is supposed to be much faster and efficient and can do much more than beautifulsoup", "note that using the beautifulsoup parser is a lot slower than lxml s default parser", "one of the things that makes lxml better than beautifulsoup is support for proper css-like class selection or even supports full css selectors if you want to use them", "pyquery is based on lxml so it s also much faster than beautifulsoup", "since you re using lxml why not use it in a more direct manner lxml is believed to be faster than beautifulsoup", "speed isn t important here but in other applications it is good to know that regexes are very fast 100 times faster than lxml and 1000 faster than beautifulsoup", "you ll probably find that lxml runs faster than beautifulsoup but in my uses beautifulsoup was very easy to learn and use and handled typical crappy html as found in the wild well enough that i don t have need for anything else", "for starters beautifulsoup is no longer actively maintained and the author even recommends alternatives such as lxml", "i do understand that traditionally they are saying that lxml are stricter than beautifulsoup however what i do not get is the following", "lxml also has more features and offers beautifulsoup too", "lxml is significantly more powerful and robust than beautifulsoup in my experienced opinion"]

sentences9 = ["swing has newer and better api s than awt", "its was said that awt is faster than swing as it uses the platform component but due the arrival of faster processor etc ..", "swing is far better then awt and should be educated to people who is writing gui-based java for the first time", "in swing has more features than the awt components", "yes swing has newer and better api s than awt", "swing or javafx would be better than awt", "consider using swing which has much better performance over the old heavyweight awt", "you can read all over the web that awt is old and deprecated and swing is old but newer than awt and should be preferred over awt whenever possible", "it has functionality the same as a canvas but swing is more advanced and has better features than awt", "well swing is richer in terms of out-of-the-box components than awt", "swing is better and few people remember how to use awt components", "swing is far better than the obsolete awt library", "as far as when awt may be more useful than swing -", "are there any cases where awt is more useful advised to use than swing or vice-versa", "alternate way is to use awt - which is an older and worse technology than swing and in that case you can t use flowlayout - it puts all the components into one row", "awt is really out of date people have more experience with swing no days and even javafx", "generally swing is more efficient and advanced than awt", "i find that the swing library is easier to use than awt although you do still have to use awt for listeners", "i know you re thinking why did i use awt instead of swing but at the moment i am more comfortable with awt", "i mean by light weight i thought maybe the swing components occupy less memory than the awt components", "in general avoid awt for swing which has much greater power and flexibility although it too is showing its age just less so than awt", "note first there is no combobox item in awt there is jcombobox in swing which is better to use than choice of awt", "performance swing components are generally slower and buggier than awt due to both the fact that they are pure java and to video issues on various platforms", "swing has more or less deprecated awt so you should extend jframe instead of frame", "swing is relatively similar to awt apart from the fact that swing has more capabilities awt is probably the simplest form to start out with and has most if not all of the tools to complete your project hope this helps", "swing will save your more time than awt as all the code of components of swing are purely written in java whereas of awt code of components are written in native language that is other than java thus compilation time of awt is more than swing", "the awt approach seems closer to bare metal but since jdk 6 brought a lot of improvements in swing rendering pipeline i would go the swing java2d approach", "the swing library is much more portable than the awt library", "use a swing gui not an awt gui since swing is much more powerful and flexible than awt", "use swing follow the threading rules which are hardly likely to be more onerous than awt and enjoy"]

sentences10 = ["according to the performance results at for serialization with databind with strings gson.tojson myobject gson is over 10x slower than jackson", "also i want to know if google gson is better than jackson for json parsing", "code looks correct and even at its worst jackson should be no slower than gson", "deserialization performance is similar with gson over 9x slower than jackson and fastjson about 0.5 faster than jackson", "further more gson really seems to be faster than jackson json", "gson 1.6 now includes a low-level streaming api and a new parser which is actually faster than jackson", "gson is faster with smaller documents and jackson is faster with large documents", "gson is simpler jackson is faster", "i looked at gson metrics and it seems slower than jackson", "i ve seen questions like this come up before and the general consensus is that jackson is much faster than gson", "in my case i found jackson little faster than gson i used default serialization because so far i don t have a need to customize serialization", "jackson is faster but the api is 37x more complex than the gson api", "jackson is more suitable if you have a complex deep json tree because gson creates a lot of temporary objects which leads to stop the world gcs", "large objects google gson performs faster than jackson and simple json", "personally i prefer jackson as according to test benchmarks it s faster than gson", "take a look at the jackson json parser it s faster than the one in android and faster than gson and supports streaming", "under some conditions gson has proven to be a lot faster than jackson there also exists jsonp and json.simple", "very small object google gson performs faster than jackson and simple json", "after searched in google found that jackson has better performance than gson i plan to replace gson with jackson in my project but i got a diffrent result when run test code", "also it seems jackson lib has better performance than other packages such as gson which i haven t tried personally", "i found jackson better than gson performance project activity better docs ...", "jackson type safety is way better than gson", "performance of jackson is better than gson", "we plan to use gson extensively in the application as it seems safer and better than jackson", "going to go ahead and say that gson is a lot more user friendly albeit less powerful than jackson", "gson is not particularly fast but the jackson library can almost compete with most binary serializers jackson is 2-4x faster than gson in most situations and 10-20x faster on utf-8 because it has special code for utf-8", "it seems gson is more faster than jackson the average time of gson is about 2ms while jackson is about 16ms does i make mistake when using jackson", "keep in mind though that jackson is a larger library than gson so depending on your case you might prefer gson to avoid 65k methods limitation", "note also that gson comes with less features out of the box than genson or jackson", "since i am more familiar with jackson here are some aspects where i think jackson has more complete support than gson apologies if i miss a gson feature", "try this lib that s a good one with the jackson we use only in the server side because jackson is more slow in the android than gson at least in our test"]

sentences11 = ["swift s compiler is also doing a lot more than objective-c s compiler considering swift is more strongly typed and does not required specifying imports among other things", "the swift compiler is doing a lot more and is quite a bit newer than the objective-c compiler so it unlikely it will be as stable fast for quite some time", "there are multiple reasons why the swift code is slower than the objective-c code", "my view is that if in some cases objective-c is faster than swift it doesn t mean that all over performance of swift is slower", "the swift one is dramatically slower then objective-c implementation", "bottom line i would personally hesitate to draw any simple conclusions of swift is faster than objective-c or vice versa", "and also apple does might not confidently announce that swift is more faster than objective-c in all the cases", "as craig revealed within the announcement of swift it is said to be faster than objective-c by far", "it is possible for swift to be faster than pure objective-c in things that you would traditionally use c or c++ for anyway", "wouldn t swift be slower than objective-c in this case since it is layered on top of it", "most importantly for your image processing app the compiler will optimize swift code to run faster than objective-c", "i don t think that as of today you can run these tests and determine with any certainty whether swift 1.0 is faster or slower than objective-c", "the perf hit will be ridiculous i know apple say swift execute faster than objective-c but this is low level so it will be harmless", "this article seems to suggest that this is possible by swizzling a fake location into apple s cllocationmanager class to be used by other apps but i am unfamiliar with the objective-c code more familiar with swift", "i m learning swift and much less familiar with objective-c but for the life of me i can t figure out how they are trying to achieve the goal stated as build list of encodings sorted and including only those with human readable names.", "however i read that swift was the successor of objective-c and i would feel more comfortable with swift syntax", "im new to swift but i like it more than objective-c as it looks a bit like java does to me from syntax wise compared to objective-c", "swift also prevents us i believe from overriding a parent class s property but also still lets us observe changes to that property--this is much better than objective-c s approach", "objective-c is much more free and easy with types and compilation checks where swift isn t", "download xcode free and learn objective-c or swift swift is easier to learn than objective-c", "early this month i started learning swift as i found it fun and easier than objective-c", "we ve seen that swift uses a more static method dispatch than objective-c which unless a class dervices from foundation nsobject prevents the style of swizzling based on remapping method implementations at runtime", "usually i find swift s method naming to be cleaner than objective-c s but init methods can be an exception", "as you can see defining a singleton class in swift is much easier than in objective-c", "on the other hand swift is easier to learn especially if you have objective-c background so it can be adopted during the time slowly and paralelly with using objective-c", "swift is lot smarter than objective-c about singleton class", "executable size of swift application is much bigger than size of objective-c application", "injecting code in a swift application is harder than it was for an objective-c application but it s still possible", "i have a objective-c application working fine and smooth to be more comfortable with swift i decided to write the unit tests for this app in swift", "with swift the code is much more readable than with objective-c", "objective-c print is more readable compared to swift", "i use objective-c more than swift", "also note that i use objective-c more than swift", "swift in that case would not be safer but less safe than objective-c", "so i ve started learning swift because it looks way better than objective-c", "better if you have a code swift is better but is not problem objective-c", "swift is neither easier to read nor understand than objective-c", "writing swift 2.0 in my professional work my personal opinion is that it s indeed ready for enterprise applications -- maybe even more than objective-c ever were", "as objective-c is the older programming language for ios or macos applications swift allows you to use those classes structs in your code", "adding lightweight generics to your objective-c api makes it easier to interface with swift because your api gets translated more precisely", "after reading some related articles i don t think swift is more effective than objective-c", "apple seems to claim that the optional type in swift is safer than nil in objective-c but i don t understand why this is so", "as you can see the swift example is more complex and error prone than your objective-c code", "but swift is less dynamically typed than objective-c and has less support for reflection", "furthermore swift is stricter than objective-c when it comes to initialisers", "however when i switch to swift 4.0 the methods declared in swift is no longer visible in objective-c", "i also use objective-c more than swift but here s what my guess is as to what the objective-c code would come to", "i feel swift is better than objective-c in many aspects but my major question is - will swift dynamic libraries support older version of swift", "i find that objective-c is much nicer for working with core audio than swift", "i know that swift is buggy as heck i run into bugs everyday but ill bet objective-c was even worse when it started out benefits of hindsight so in a couple of years swift will be equal or greater than objective-c keeping its basic simplicity as well", "if you get a difference between swift and objective-c it s more because swift is probably better on optimisation", "it seems to me that swift would be way simpler to learn then objective-c for beginners i know because i learned it in like 2 months and swift is less complicated and better laid out then objective-c", "no objects come magically into existence in swift any more than in objective-c", "note that swift s arrays are much more sensible than objective-c s", "objective-c -documentary provides more content than the documentary for swift", "one of the reasons we want to move is because swift is more secure than objective-c", "or is it merely a hint to whatever tool converts between swift and objective-c to better deal with swift optionals", "personally i prefer objective-c because you can use c very easily as anything that is legal in c is also legal in objective-c added to which swift is a more procedural in style where objective-c is quite clearly object orientated", "so it should have always been gkagent under objective-c in order to be strictly correct however objective-c is less type-safe than swift so you could get away with it with the possibility that you d get an unrecognized selector exception if a gkagent object was ever passed to the delegate method and you assumed it was a gkagent2d", "specifically it makes it possible to write objective-c code that plays nicely with swift which is more strongly typed than objective-c", "swift is clearer on versions releases and i keep asking myself if i am missing something related to objective-c since i can t find this information", "swift is more strictly typed than objective-c", "swift is stricter about runtime type correctness than objective-c so duck typing alone is not enough", "swift seems to be less dynamic than objective-c in these stuffs", "swift will incur this penalty in fewer situations than objective-c will for instance method calls to swift-only protocol methods do not hit objc_msgsend but if the protocol is declared in objective-c or if the swift protocol is decorated with objective-c such that it can be adopted by objective-c objects as well then method calls to methods in that protocol adopted by swift objects appear to be dispatched via objc_msgsend", "swift won t allow you to do absolutely everything that objective-c does but it will allow you to do almost everything and the code will be probably more robust considering that swift is more modern language with stronger typing than objective-c", "the swift designers went through a lot of trouble to make sure that it s more than just objective-c without the constraints of c in fact i almost wish they hadn t said that since it s so often misquoted", "the swift runtime is smaller than the objective-c runtime", "this is because the swift dictionary is more strongly typed than the objective-c nsdictionary", "those attributes let you create objective-c code which is more understandable by swift and complier warn you when you break the rule for example", "while i think the move to swift is prudent but i think it overstates the case to argue that swift is significantly more secure that objective-c", "you will notice that swift bundles are always about 4-5 mb larger than their objective-c counterparts and this is precisely why"]

sentences12 = ["and it sounds strange but jruby scales very well and it s faster than mri with java 7", "mri is faster than jruby", "mri has a gil so why is it faster than jruby in handling requests", "so it seems like the opposite - mri 2.3 gets 2-5x slower than jruby 9.1", "this really surprised me because i expected mri to be slower than jruby", "jruby is faster than 1.9 mri matz ruby interpreter the standard in certain areas", "for example jruby is faster than mri jruby 1.7 is faster than jruby 1.6 jruby 1.7 running on hotspot is faster than jruby 1.7 running on j9 jruby 1.7 running on hotspot 1.7 is faster than jruby 1.7 running on hotspot 1.6 jruby 1.7 running on hotspot 1.7 with the c2 compiler is faster than jruby 1.7 running on hotspot 1.7 with the c1 compiler and so on", "does this mean that the old adagio about jruby being faster than mri ruby is gone", "with these options jruby on rails gives about the same or better performance than mri", "for longer-running applications like a web application rubinius or jruby will generally perform better than mri", "i know that rails jruby handles concurrency better than mri but i don t know how to do it", "lastly if you are frequently finding yourself running long running process i advice you to try jruby which is works much better with long running processes due to jvm lot faster than mri", "sometimes mri is faster but with the right parameters and warmup jruby was 3 to 3.5 times as fast on my system for this particular", "once the jvm has warmed up rails requests under jruby are usually significantly more performant than under mri both in terms of raw execution speed and garbage collection", "jvm hosted languages are generally going to be faster than traditional mri ruby and both java and scala are generally faster than jruby when it comes to raw cpu capabilities", "in fact on windows jruby passes more rubyspec tests than ruby meaning mri or yarv itself", "alter your command path so that jruby s version of the ruby command has a higher priority than the mri one", "the jruby runtime alone is already pretty heavy much heavier than mri", "i ve noticed however that jruby is more sensitive to memory leaks than mri"]

sentences13 = ["on some arm platform im working on memmove was 3 times faster than memcpy for short unalligned load", "so in what platform and how memcpy can be significantly faster than memmove if there is none why providing two similiar functions instead of just memmove and lead to a lots of bug", "why is memcpy so much slower than memmove or hand rolled copy on the server", "std memmove may be very slightly slower than std memcpy emphasis added because it has to first check whether the source and target ranges overlap", "edit memmove is 2x faster than memcpy on the server", "from reading other so questions such as this or this gives the impression that memcpy should work faster than memmove and intuitively this should be so", "memcpy is still a little bit slower than memmove", "and it said memmove might be very slightly slower than memcpy", "bad news is that the asmlib version of memmove is slower than the glibc version it is now running at the 300ms mark on par with the glibc version of memcpy", "why does memcpy perform slower than memmove on my system", "the question is about is there really any platform where memcpy is faster than memmove", "this means that memmove might be very slightly slower than memcpy as it cannot make the same assumptions", "as an aside my c c++ is rusty but is not memcpy more efficient than memmove if you know you don t have overlapping memory", "as already pointed out in other answers memmove is more sophisticated than memcpy such that it accounts for memory overlaps", "if you know buffers cannot overlap memcpy is fine and may in any given library use optimizations that allow it to be faster than memmove", "in addition as mats petersson said memmove is cache friendlier than memcpy", "it is entirely possible that in most implementations the cost of a memmove function call will not be significantly greater than memcpy in any scenario in which the behavior of both is defined", "memcpy is more efficient than memmove. in general use memmove only if you have to", "memmove on the laptop runs slower than memcpy but oddly enough runs at the same speed as the memmove on the server", "note that memmove has more overhead than memcpy because it has to determine which direction of copying is safe", "while memmove will be only slightly slower than memcpy due to the assumptions it needs to make about the source and destination in memcpy they cannot overlap it should still be far superior to any standard loop"]


sentences14 = ["note that the effective key size of aes is larger than triple des", "i ve read that aes encryption is more secure than the triple des encryption ms is using in their example above", "according to this analysis aes rijndael-128 is more than twice as fast as des 3des with a bigger key size more secure", "this shows that the timings are sensitive to buffering and that aes is faster than des", "aes can be even much faster than des or 3des when the cpu supports aes-ni", "using des assuming it s a little faster than aes and requires a smaller key and", "aes will indeed yield a considerably faster result than des", "if aes is negotiated it s faster than des and 3des used by default by older applications", "des turned out to be even slower than aes but for my current requirements a much simpler algorythm rc4 is sufficient", "des is usually substantially slower than aes on modern hardware and has keys that are far too short for modern use", "also see why aes is more secure than des", "edit 3des is better than des in the sense that it s significantly more secure but still less secure than aes but its performance is of necessity significantly worse than aes des or twofish because you re essentially applying des three times", "if you used aes then you might see a better speedup over the des 3des observations", "though it s unrelated to your actual question des is generally slower than aes at least in software so unless you really need to keep the key small aes is almost certainly a better choice", "turns out this was a hardware failure the aes commands need more power than the des crypto1 ones 50 more which the antenna failed to deliver at the reading range i was testing with", "which steps of aes encryption makes it less vulnerable than des"]


print(datetime.datetime.now())

embed = hub.Module("https://tfhub.dev/google/universal-sentence-encoder-large/3")
print(1)
init_op = tf.global_variables_initializer()
init_table = tf.tables_initializer()
sess = tf.Session()
sess.run(init_op)
sess.run(init_table)
embeddings = embed([
    "The quick brown fox jumps over the lazy dog.",
    "I am a sentence for which I would like to get its embedding"])
print(2)


# corpus=[]
# vec_sentences_formatted=[]
# for idx in range(len(sentences2)):
#     temp = sentences[idx].replace(pair[0], "*")
#     temp = temp.replace(pair[0], "*")
#     vec_sentences_formatted.append(temp)
#     corpus.append(' '.join([w for w in temp.split() if w not in stop_words]))
vec = sess.run(embed(sentences6))
print(datetime.datetime.now())


n = 6
cluster = AgglomerativeClustering(n_clusters=n, affinity='euclidean', linkage='ward')
clusterss = cluster.fit_predict(vec)
print(clusterss)
for s in clusterss:
    print(s)
cluster = AgglomerativeClustering(n_clusters=n, affinity='euclidean', linkage='average')
clusterss = cluster.fit_predict(vec)
print(clusterss)
cluster = AgglomerativeClustering(n_clusters=n, affinity='euclidean', linkage='complete')
clusterss = cluster.fit_predict(vec)
print(clusterss)
cluster = AgglomerativeClustering(n_clusters=n, affinity='l1', linkage='average')
clusterss = cluster.fit_predict(vec)
print(clusterss)



nbrs = NearestNeighbors(2).fit(vec)
distances, indices = nbrs.kneighbors(vec)
distances = np.sort(distances, axis=0)
distances = distances[:,1]
# plt.plot(distances)
# plt.show()
eps = distances.mean()
print("eps is: ",eps)
db = DBSCAN(eps=0.59, min_samples=1)
db.fit(vec)
clusters = db.labels_.tolist()

print(db.fit_predict(vec))

db = DBSCAN(eps=0.59, min_samples=4)
db.fit(vec)
clusters = db.labels_.tolist()

print(db.fit_predict(vec))


op = OPTICS(max_eps=0.59)
op.fit(vec)
print(op.fit_predict(vec))

print(datetime.datetime.now())

