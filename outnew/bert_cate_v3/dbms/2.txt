i found that * is too slow at least much slower than * even on relatively small 150k datasets when searching records by text pattern despite the presence of indices

* looks more fancy and advanced but not as popular as * and is not supported on heroku

using * that is supposed ti be faster than * for depth i m seeing a slow performance

i read in some blog that * performs at least as good if not better than * while also offering more complex types like mongodb would

the number of requests * could serve is consistently 3 to 5 times lower than *

* is more permissive and allows the non-standard use of distinct but * throws an error

* mariadb is slightly worse than *

with django it is easy to use * instead of * so i tried it with the same query and same data in db * is much faster that * x10 more faster while using inner join analyse shows it uses indexes unlike *

i found that * 9.3 has better capabilities for json than the * versions i am using

in your case * may be a better option than * because your query is going to likely be against secondary indexes

* run 4x faster than *

i hear * is more robust and doesn t crash like * does in these situations

not only does * have a far more flexible indexing than * but the table approaches are very different also meaning the appropriate indexing strategies are as different as the tactics are

* is much more similar to oracle than * is

explain in * is way more useful than in *

in my cases * was better than * * do not completely support unicode

there are workloads where * is better and there are workloads where * is better

honestly though * scales much better than *

what i am hearing from our group leader is that * is better than * when working with coordinates

* is way better than * in nearly every respect

* is more widely supported and a little easier to use but * has some very cool features and functionality that s worth taking a gander at

i did some benchmarking 3 years ago may be stale... which showed that on large datasets basically * fulltext is 10-100x faster than * and xapian 10-100x faster than * but not integrated

* is much more complete and solid and will much better support complex queries and their optimization while * may shine in terms of retrieval speed for extremely simple queries

* is stricter about conversions than * is and generally will throw an error rather than try to convert a string to an integer if it doesn t look like one

i just recently switched databases to * which has given me a slew of problems although i must admit i like it a lot better than *

* is a little more strict than * about type conversion and does not let you implicitly cast convert between numbers and strings

while * is more famous for serious enterprise-quality database where preserving your data is critical i recommend *

* is picky pickier than * -- all fields in the select list when using distinct must be present in the order_by and group_by clauses

following the first answer it appears that * is more compliant to sql standard than * so it needs a group by clause for each selected column you want to display with your aggregated function

the question is is * somehow more resistant than * to sql injection attack under the perl dbi and why might this be the case

* is far more powerful and scalable and doesn t have * s silly limitations and gotchas

then * is much better than *

i d have said that * is more security aware than * supporting roles more authentication methods ... but that the database itself has generally a very limited impact on the security of an application

you might look at * as i find it a bit easier to manage and maintain as i feel some aspects are more logical than *

* i am told can be optimized to do faster reads than * but both are pretty ridiculously fast in terms of # transactions sec they support and it doesn t sound like that s your problem

i had mentioned that in our rails application all select queries dropped below 100ms after switching to * whereas some of the complex joins generated by activerecord would occasionally take as much as 15s or more with * 5.1 because of nested loops with inner table scans even when indices were available

is * a better option than * for partitioning tables by date

in general * knows more tricks for how to optimize complicated queries than the * optimizer does but it also relies heavily on your having given the optimizer enough data to work with

unfortunately in * select count is often slower than * to which it often get s compared to

according to my own experience * run much faster than * especially handling big tables 1.4 gb lineitem table in my case

* supports some more security features than * for example integration with gssapi or kerberos for logins last i checked * didn t have these

anyways * is bad and on longterm especially if you are enough good for java i suggest you to use some better db with * you were really satisfied i think

i really like * s indexes which are far better than * s

some say * is much better for bigger projects while others think just go with *

i d also recommend * over * if you are going to have nested comments as * does hierarchical querying better than *

it s a shame * isn t more popular than * since it supports exactly this feature out-of-the-box you d only have to share one sequence object between tables.

but in * it is ok and in * it is wrong and ask for the other fields besides site_id either in a group by clause or in a aggregation function i know that * is stricter on sql than * so i must select the site_id in the query object of msg_published but in pure sqlalchemy i can do like this

* is stricter to the sql standard than * is

* and other similar solutions should work a bit better than * depending on your data sets and use cases

